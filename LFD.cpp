#include <cstdlib> // for rand, srand, RAND_MAX
#include <fstream>
#include <string>
#include <cmath>
#include "LFD.h"
using namespace std;

// compute cross entropy error for d=2, linear model with classification
// y = +1 or -1
double cross_entropy(double * x1, double *x2, double *w, double *y, int num_pts)
{
	double ret = 0;
	for (int i = 0; i < num_pts; i++)
	{
		ret += log(1+ exp(-y[i]*(w[0]+ w[1]*x1[i]+w[2]*x2[i])))/num_pts;
	}
	return ret;
	
}

//generate a random double in the range [-1,1]
double drand()
{
	double ret;
	ret = 2*((double) rand())/RAND_MAX - 1;
	return ret;
}

//generate a set of points (x1,x2) consisting of num_pairs points
void generate_points(string filename, int num_pairs)
{
	ofstream fout(filename);
	
	for (int i = 0; i < num_pairs; i++)
	{
		fout << drand() << "  " << drand() << '\n';
	}
	fout.close();
	
}

void generate_points_with_dependent(string filename, int num_pairs, double * target)
{
	ofstream fout(filename);
	double x1, x2;
	
	for (int i = 0; i < num_pairs; i++)
	{
		x1 = drand();
		x2 = drand();
		fout << x1 << "  " << x2 << " ";
		fout << test_point(x1,x2,target) << '\n';
	}
	fout.close();
	
}

void makeline( double * line)
{
	double x1 = drand();
	double x2 = drand();
	double y1 = drand();
	double y2 = drand();
	
	line[0] = -y1*x2 + x1*y2;
	line[1] = y1-y2;
	line[2] = x2-x1;
	
}

int count_mismatches(double * data_x, double * data_y, 
						double * target, double * hypothesis, int num_pts)
{
	int counter = 0;
	for (int i = 0; i < num_pts; i++)
	{
		if (test_point(data_x[i],data_y[i],hypothesis) !=
			 test_point(data_x[i],data_y[i],target))
		{
			counter++;
		}	
	}
	return counter;	
}


int test_point(double x1, double x2, double * hypo)
{
	if(hypo[1]*x1 + hypo[2]*x2 >= -hypo[0])
		return 1;
	else 
		return -1;
}

void report_line(string filename, double * line)
{
	ofstream line_out(filename);
	line_out << line[1] << " " << line[2]
		<< " " << line[0] << endl;
	line_out.close();
}

// use PLA to update hypothesis.  Returns number of iterations needed
int PLA_update(double * x1, double * x2, double *target, double * w, int num_points)
{
	int count_iter=0;
	int index;
	int test_val;
	int target_val;


	while(count_mismatches(x1,x2,w,target,num_points) != 0)	
	{
		do{
			index = rand() % num_points;
			test_val = test_point(x1[index],x2[index],w);
			target_val = test_point(x1[index],x2[index],target);
		}
		while(test_val == target_val);
	
		w[0] = w[0] + target_val;
		w[1] = w[1] + target_val*x1[index];
		w[2] = w[2] + target_val*x2[index];	
		count_iter++;
	}
	
	return count_iter;
}

double sqdifference(double * w1, double * w2, int dim)
{
	double ret = 0;
	for (int i = 0; i <dim ; i++)
		ret += (w1[i]-w2[i])*(w1[i]-w2[i]);
	return ret;
}

//pseudorandom perms generated by repeatedly swapping
//randomly chosen elements of an ordered array
void generate_rand_perm(int n, int * x)
{
	int tmp,j1,j2;
	for (int i = 0; i < n; i++)
		x[i] = i+1;
	for (int i = 0; i < 2*n; i++)
	{
		j1 = rand() % n;
		j2 = rand() % n;
		tmp = x[j1];
		x[j1] = x[j2];
		x[j2] = tmp;
	}
}


